"""
File: parser.py
Author: Timo L. R. Halbesma <timo.halbesma@student.uva.nl>
Date created: Mon Apr 18, 2016 02:19 pm
Last modified: Mon Apr 18, 2016 10:30 pm

Parse output of Julius Donnert's Toycluster 2.0 IC generator.

Class Gadget2BinaryF77UnformattedType2Parser
    - Parse unformatted Fortran 77 binary file of Gadget-2 type 2.
    - File to parse contains IC file written by Toycluster 2.0
Class Toycluster2RuntimeOutputParser
    - Parse Toycluster 2.0 runtime output
    - Can eat raw output of Sun Grid Engine (qsub); the footer is ignored.
"""

import numpy

from amuse.units import units


# Gadget2BinaryF77UnformattedType2Parser helper functions
def read_block(f, fmt="int8"):
    """ Read Fortran 77 unformatted block """
    # First block: header (new in Gadget2 filetype)
    length = numpy.fromfile(f, dtype=numpy.uint32, count=1)
    content = numpy.fromfile(f, dtype=fmt, count=length)
    end_length = numpy.fromfile(f, dtype=numpy.uint32, count=1)

    if end_length != length:
        print "error: blocklengths differ"
        return None
    return content


def get_blockname(block):
    """ Get Fortran 77 unformatted header block name,
        translate ascii values to string """
    # TODO: this code could probably be written way more elegent
    name = ""
    for char in block:
        if 65 <= char <= 90:
            name += chr(char)
        else:
            break
    return name


# Toycluster2RuntimeOutputParser helper functions
def distance_str_to_quantity(s):
    """ Eat string, return AMUSE quantity, e.g. '6961.5 kpc' """
    value, unit = s.split(" ")
    if unit != "kpc":
        print "Warning: incorrect distance unit parsed. {0} {1}".format(value, unit)
    quant = float(value) | units.kpc
    return quant


def mass_str_to_quantity(s):
    """ Eat string, return AMUSE quantity, e.g. '100000 10^5 MSol' """
    # TODO: change code_unit_mass to mass read from System of Units block
    code_unit_mass = 1e10  # for now, read this also from toycluster output
    value, factor, unit = s.split(" ")
    if unit != "MSol" and unit != "Msol":
        print "Warning: incorrect mass unit parsed. {0} {1} {2}"\
            .format(value, factor, unit)
    if factor != "10^5":
        print "Warning: incorrect mass factor parsed. {0} {1} {2}"\
            .format(value, factor, unit)
    # Warning, the raw output is e.g. 100000 10^5 MSol, so something
    #     strange is going on with the code_unit_mass and the 10^5 ?
    quant = float(value) * code_unit_mass | units.MSun

    return quant


def unit_str_to_quantity(s):
    raw_value, unit = s.split(" ")
    try:
        value, power = raw_value.split("e")
        value = float(value) * 10**int(power)
    except ValueError as e:
        # Has no "e+" throws "need more than 1 value to unpack"
        if e.message != "need more than 1 value to unpack":
            raise
        # print "Warning! ValueError", e, "occurred for unit:", raw_value, unit
        value = raw_value
        power = 0
    if unit == "cm":
        return units.cm(value)
    elif unit == "sec":
        return units.s(value)
    elif unit == "g":
        return units.g(value)
    elif unit == "cm/s":
        return value | units.cm/units.g
    elif unit == "g/cm^3":
        return value | units.g/units.cm**3
    elif unit == "erg":
        return units.erg(value)
    else:
        print "Error: Unit not defined. Add it :-)"
        return None


class Gadget2BinaryF77UnformattedType2Parser(object):
    """
    Parse unformatted Fortran 77 binary file of Gadget-2 type 2.
    File to parse contains IC file written by Toycluster 2.0

    Based on Springel's read_snapshot_single.pro, but in Python.
    Useful documentation for porting IDL script to Python:
        - http://www.harrisgeospatial.com/docs/fltarr.html
        - http://www.harrisgeospatial.com/docs/idl_ese_datatypes.html

    Tested only with Dr. Donnert's Toycluster 2.0 output (IC-file),
    git commit b5dbfddf8848bab26b8cc5337dc95af1e0164326 with some changes.
    Makefile:
        DZERO_ENERGY_ORBIT_FRACTION=0.0; no substructure; compiler=icc
    cluster.par:
        Bfld values set to 0
    """
    def __init__(self, filename="../input/IC_single_0"):
        print "Parsing ICs generated by Toycluster 2.0\n"

        with open(filename, "rb") as f:
            self.read_ic(f)

    def read_header(self, f):
        """ First block is the header. See Gadget-2 user guide for details. """
        # TODO: store these data in a dictionary instead of instance attributes
        blocklength = numpy.fromfile(f, dtype=numpy.uint32, count=1)

        # TODO: Implement as single fromfile with dtype/count array?
        self.npart = numpy.fromfile(f, dtype=numpy.uint32, count=6)
        self.massarr = numpy.fromfile(f, dtype=numpy.float64, count=6)
        self.time = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.redshift = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.flag_sfr = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]  # unused in public version of GADGET-2
        self.flag_feedback = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]  # unused
        self.npartTotal = numpy.fromfile(f, dtype=numpy.int32, count=6)
        self.flag_cooling = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]
        self.numFiles = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]
        self.boxSize = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.omega0 = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.omegalambda = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.hubbleParam = numpy.fromfile(f, dtype=numpy.float64, count=1)[0]
        self.flag_age = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]  # unused
        self.flag_metals = numpy.fromfile(f, dtype=numpy.int32, count=1)[0]  # unused
        self.numpart_total_hw = numpy.fromfile(f, dtype=numpy.int32, count=6)  # unused

        bytesleft = 256-6*4 - 6*8 - 8 - 8 - 2*4-6*4 - 4 - 4 - 8 - 8 - 8 - 8 - 4 - 4 - 6*4
        self.la = numpy.fromfile(f, dtype=numpy.uint16, count=bytesleft/2)

        blocklength_end = numpy.fromfile(f, dtype="uint32", count=1)
        # print blocklength_end
        if blocklength != blocklength_end:
            print "error: blocklengths differ"

    def read_ic(self, f):
        """
            See Gadget-2 user guide for details. The data blocks are:
            Block 0 (Coordinates)
            Block 1 (Velocities)
            Block 2 (ParticleIDs)
            Block 3 (Density)         <-- gas only
            Block 4 (Model Density)   <-- gas only
            Block 5 (SmoothingLength) <-- gas only
            Block 6 (InternalEnergy)  <-- gas only
            Block 7 (MagneticField)   <-- gas only
        """
        content = read_block(f)
        if get_blockname(content) == "HEAD":
            self.read_header(f)

        self.N = numpy.sum(self.npart)
        self.Ngas = self.npart[0]
        self.Ndm = self.npart[1]

        # TODO: shove this into a loop, e.g. while end of file not is reached
        # read block, check blockname, call correct function to parse block
        # now this is in the order the blocks were written but other gadget2 files might differ.
        content = read_block(f)
        #  TODO: just read N bytes because we know the blocklength as it is written in the file
        # afterwards we can get the correct numbers because we know the datatype for a given attribute
        if get_blockname(content) == "POS":
            content = read_block(f)
            # https://stackoverflow.com/questions/23377274
            self.pos = numpy.empty((self.N, 3), dtype="float32")
            tmppos = numpy.frombuffer(content, dtype="float32", count=self.pos.size)
            self.pos = numpy.reshape(tmppos, self.pos.shape)

        content = read_block(f)
        if get_blockname(content) == "VEL":
            content = read_block(f)
            self.vel = numpy.empty((self.N, 3), dtype="float32")
            tmpvel = numpy.frombuffer(content, dtype="float32", count=self.vel.size)
            self.vel = numpy.reshape(tmpvel, self.vel.shape)

        content = read_block(f)
        if get_blockname(content) == "ID":
            content = read_block(f)
            self.ids = numpy.frombuffer(content, dtype="uint32", count=self.N)

        # TODO: test this, because the binary file used to test does not have individual masses
        # If the particles have individual masses the next block contains the masses
        # ind = numpy.intersect1d(numpy.nonzero(self.npart), numpy.where(self.massarr == 0.0))
        # self.Nwithmass = numpy.sum(self.npart[ind])
        self.Nwithmass = 0

        if self.Nwithmass > 0:
            print "Warning: this code is untested, check output!"
            print "particles have individual mass"
            content = read_block(f)
            if get_blockname(content) == "MASS":
                content = read_block(f)
                self.mass = numpy.frombuffer(content, dtype="float32", count=self.Nwithmass)
            print "TODO: store mass with correct particle, split flat array"

        if self.Ngas > 0:
            content = read_block(f)
            if get_blockname(content) == "RHO":
                content = read_block(f)
                self.rho = numpy.frombuffer(content, dtype="float32", count=self.Ngas)
            content = read_block(f)

            if get_blockname(content) == "RHOM":
                content = read_block(f)
                self.rhom = numpy.frombuffer(content, dtype="float32", count=self.Ngas)

            content = read_block(f)
            if get_blockname(content) == "HSML":
                content = read_block(f)
                self.hsml = numpy.frombuffer(content, dtype="float32", count=self.Ngas)

            content = read_block(f)
            if get_blockname(content) == "U":
                content = read_block(f)
                self.u = numpy.frombuffer(content, dtype="float32", count=self.Ngas)

        magnetic_field = True
        if magnetic_field:
            content = read_block(f)
            if get_blockname(content) == "BFLD":
                content = read_block(f)
                self.bfld = numpy.frombuffer(content, dtype="float32", count=self.Ngas)

    @property
    def str_header(self):
        """ store header data in string """
        tmp = "npart: \t\t" + str(self.npart) + "\n"
        tmp += "massarr: \t" + str(self.massarr) + "\n"
        tmp += "time: \t\t" + str(self.time) + "\n"
        tmp += "redshift: \t" + str(self.redshift) + "\n"
        tmp += "flag_sfr: \t" + str(self.flag_sfr) + "\n"
        tmp += "flag_feedback: \t" + str(self.flag_feedback) + "\n"
        tmp += "npartTotal: \t" + str(self.npartTotal) + "\n"
        tmp += "flag_cooling: \t" + str(self.flag_cooling) + "\n"
        tmp += "numFiles: \t" + str(self.numFiles) + "\n"
        tmp += "boxSize: \t" + str(self.boxSize) + "\n"
        tmp += "omega0: \t" + str(self.omega0) + "\n"
        tmp += "omegalambda: \t" + str(self.omegalambda) + "\n"
        tmp += "hubbleParam: \t" + str(self.hubbleParam) + "\n"
        tmp += "flag_age: \t" + str(self.flag_age) + "\n"
        tmp += "flag_metals: \t" + str(self.flag_metals) + "\n"
        tmp += "la: \t\t" + str(self.la) + "\n"

        return tmp

    @property
    def str_particles(self):
        """ store particle data in string """
        tmp = "POS\n"
        tmp += str(self.pos[0:10]) + "\n...\n" + str(self.pos[-10:])
        tmp += "\n\nVEL\n"
        tmp += str(self.vel[0:10]) + "\n...\n" + str(self.vel[-10:])
        tmp += "\n\nID\n"
        tmp += str(self.ids[0:10]) + "\n...\n" + str(self.ids[-10:])
        tmp += "\n\nRHO\n"
        tmp += str(self.rho[0:10]) + "\n...\n" + str(self.rho[-10:])
        tmp += "\n\nRHOM\n"
        tmp += str(self.rhom[0:10]) + "\n...\n" + str(self.rhom[-10:])
        tmp += "\n\nHSML\n"
        tmp += str(self.hsml[0:10]) + "\n...\n" + str(self.hsml[-10:])
        tmp += "\n\nU\n"
        tmp += str(self.u[0:10]) + "\n...\n" + str(self.u[-10:])
        tmp += "\n\nBFLD\n"
        tmp += str(self.bfld[0:10]) + "\n...\n" + str(self.bfld[-10:])

        return tmp

    def __str__(self):
        tmp = self.str_header + "\n" + self.str_particles
        return tmp


class Toycluster2RuntimeOutputParser(object):
    """
    Parse Toycluster 2.0 runtime output
    Can eat raw output of Sun Grid Engine (qsub); the footer is ignored.

    This function then reads the cluster and system settings

    WARNING! The numbers have huge rounding errors due to printing .4f or so!
    """
    def __init__(self, filename):
        print "Parsing runtime output of Toycluster 2.0"
        print "Warning: these values have rounding errors due to printing!\n"

        self.eat_file(filename)
        self.parse_units()
        self.parse_systemat()
        self.parse_setup()
        self.parse_halo0()
        # self.parse_halo0_sampling()

    def eat_file(self, filename):
        """ Eat the file and find indices where listings start. """
        with open(filename) as f:
            self.lines = f.readlines()

        for i, line in enumerate(self.lines):
            if line.startswith("Setting System of Units:"):
                self.units_i = i
            if line.startswith("System at:"):
                self.systemat_i = i
            if line.startswith("Halo Setup : <0>"):
                self.halo0_i = i
            if line.startswith("System Setup :"):
                self.setup_i = i
            if line.startswith("Grav. Softening"):
                self.grav_softening = distance_str_to_quantity(line.split(" ~ ")[-1].strip())
            # NB this is in the file twice: before and after WVT?
            if line.startswith("Sampling of Halo <0>"):
                self.halo0_sampling_i = i

    def split(self, s):
        """ Split string 'name = value' and strip newline character. """
        return s.split(" = ")[-1].strip()

    def parse_units(self):
        """ Parse block that contains system of units. """
        # TODO: store these data in a dictionary instead of instance attributes
        lines = self.lines

        # Set Unit parameters
        i = self.units_i
        self.units_length = unit_str_to_quantity(self.split(lines[i+1]))
        self.units_time = unit_str_to_quantity(self.split(lines[i+2]))
        self.units_mass = unit_str_to_quantity(self.split(lines[i+3]))
        self.units_vel = unit_str_to_quantity(self.split(lines[i+4]))
        self.units_density = unit_str_to_quantity(lines[i+5].split("= ")[-1].strip())
        self.units_energy = unit_str_to_quantity(self.split(lines[i+6]))

    def parse_systemat(self):
        """ Parse block with cosmological (system at) parameters. """
        # TODO: store these data in a dictionary instead of instance attributes
        lines = self.lines

        # Set System At parameters
        i = self.systemat_i

        self.system_z = float(self.split(lines[i]))
        self.system_H_over_100 = float(self.split(lines[i+1]))
        self.system_Omega_M = float(self.split(lines[i+2]))
        self.system_rho_crit_0 = unit_str_to_quantity(self.split(lines[i+3]))
        self.system_rho_crit_z = unit_str_to_quantity(self.split(lines[i+4]))
        self.system_mean_mol_w = float(lines[i+5].split("= ")[-1].strip())
        self.system_E_of_z = float(self.split(lines[i+6]))
        self.system_Delta = float(self.split(lines[i+7]))

    def parse_halo0(self):
        """ Parse block that contains halo <0> parameters """
        # TODO: add halo1 if a mass ratio is set to a nonzero value.
        # TODO: store these data in a dictionary instead of instance attributes
        lines = self.lines

        # Set Halo 0 parameters
        i = self.halo0_i

        self.halo0_model = lines[i+1].split("=")[-1].strip()
        self.halo0_rgas = distance_str_to_quantity(lines[i+2].split("=")[-1].strip())
        self.halo0_rdm = distance_str_to_quantity(lines[i+3].split("=")[-1].strip())
        self.halo0_qmax = float(lines[i+4].split("=")[-1].strip())
        self.halo0_Mass = mass_str_to_quantity(lines[i+5].split("=")[-1].strip())
        self.halo0_Mass_in_DM = mass_str_to_quantity(lines[i+6].split("=")[-1].strip())
        self.halo0_Mass_in_gas = mass_str_to_quantity(lines[i+7].split("=")[-1].strip())
        self.halo0_Mass_in_R200 = mass_str_to_quantity(lines[i+8].split("=")[-1].strip())
        self.halo0_c_nfw = float(lines[i+9].split("=")[-1].strip())
        self.halo0_R200 = distance_str_to_quantity(lines[i+10].split("=")[-1].strip())
        self.halo0_a_hernquist = distance_str_to_quantity(lines[i+11].split("=")[-1].strip())
        self.halo0_rho0gas_cgs = unit_str_to_quantity(self.split(lines[i+12]))
        self.halo0_rho0gas_gadget = (lines[i+13].split("=")[-1].strip()).split(" ")[0]
        if lines[i+14].split("=")[-1].strip() == "2/3": self.halo0_beta = 2./3
        self.halo0_rc = distance_str_to_quantity(lines[i+15].split("=")[-1].strip())
        # self.halo0_rcut = distance_str_to_quantity(lines[i+16].split("=")[-1].strip())
        self.halo0_R500 = distance_str_to_quantity(lines[i+16].split("=")[-1].strip())
        self.halo0_bf_200 = float(lines[i+17].split("=")[-1].strip())
        self.halo0_bf_500 = float(lines[i+18].split("=")[-1].strip())

    def parse_setup(self):
        """ Parse block that contains the system setup parameters. """
        # TODO: store these data in a dictionary instead of instance attributes
        lines = self.lines

        # Set System Setup parameters
        i = self.setup_i
        self.system_boxsize = distance_str_to_quantity(lines[i+1].split("=")[-1].strip())
        self.system_TotalMass = mass_str_to_quantity(lines[i+2].split("=")[-1].strip())
        self.system_Mass_in_gas = mass_str_to_quantity(lines[i+3].split("=")[-1].strip())
        self.system_Mass_in_DM = mass_str_to_quantity(lines[i+4].split("=")[-1].strip())
        self.system_Mass_Ratio = float(lines[i+5].split("=")[-1].strip())
        self.system_given_bf = float(lines[i+6].split("=")[-1].strip())
        self.system_boxwide_bf = float(lines[i+7].split("=")[-1].strip())
        self.system_npart = float(lines[i+8].split("=")[-1].strip())
        self.system_Sph_Part_mass = mass_str_to_quantity(lines[i+9].split("=")[-1].strip())
        self.system_DM_Part_mass = mass_str_to_quantity(lines[i+10].split("=")[-1].strip())
        # Warning: not in correct dataformat
        self.system_npart_partent = lines[i+11].split("=")[-1].strip()
        self.system_npart_bullet = lines[i+12].split("=")[-1].strip()
        self.system_npart_total = lines[i+13].split("=")[-1].strip()

    def parse_halo0_sampling(self):
        """ Parse block with halo parameters after sph regularisation (?) """
        # TODO: store these data in a dictionary instead of instance attributes
        lines = self.lines

        # Set Halo0 sampling parameters
        i = self.halo0_sampling_i

        print "Not implemented"
        # TODO: implement this function :-)...

        #Sampling of Halo <0> (r200 = 1856.46 kpc):
        #   Gas Mass in R200    = 1.4563e+14 Msol
        #   DM Mass in R200     = 8.53783e+14 Msol
        #   Total Mass in R200  = 9.99413e+14 Msol
        #   External Gas Mass   = 5.14206e+13 Msol
        #   External DM  Mass   = 5.42529e+14 Msol
        #   Total External Mass = 5.93949e+14 Msol
        #   Effective bf in r200= 0.17057

    def __str__(self):
        # Units
        tmp = self.lines[self.units_i].strip() + "\n"
        tmp += "    Unit Length       = " + str(self.units_length) + "\n"
        tmp += "    Unit Time         = " + str(self.units_time) + "\n"
        tmp += "    Unit Mass         = " + str(self.units_mass) + "\n"
        tmp += "    Unit Vel          = " + str(self.units_vel) + "\n"
        tmp += "    Unit Density      = " + str(self.units_density) + "\n"
        tmp += "    Unit Energy       = " + str(self.units_energy) + "\n\n"

        # System at
        tmp += "System at:          z = {0}".format(self.system_z) + "\n"
        tmp += "   H/100              = " + str(self.system_H_over_100) + "\n"
        tmp += "   Omega_M            = " + str(self.system_Omega_M) + "\n"
        tmp += "   rho_crit(0)        = " + str(self.system_rho_crit_0) + "\n"
        tmp += "   rho_crit(z)        = " + str(self.system_rho_crit_z) + "\n"
        tmp += "   mean mol. w.       = " + str(self.system_mean_mol_w) + "\n"
        tmp += "   E(z)               = " + str(self.system_E_of_z) + "\n"
        tmp += "   Delta              = " + str(self.system_Delta) + "\n\n"

        # Halo 0
        tmp += self.lines[self.halo0_i].strip() + "\n"
        tmp += "    Model             = " + str(self.halo0_model) + "\n"
        tmp += "    Sample Radius Gas = " + str(self.halo0_rgas) + "\n"
        tmp += "    Sample Radius DM  = " + str(self.halo0_rdm) + "\n"
        tmp += "    qmax              = " + str(self.halo0_qmax) + "\n"
        tmp += "    Mass              = " + str(self.halo0_Mass) + "\n"
        tmp += "    Mass in DM        = " + str(self.halo0_Mass_in_DM) + "\n"
        tmp += "    Mass in Gas       = " + str(self.halo0_Mass_in_gas) + "\n"
        tmp += "    Mass in R200      = " + str(self.halo0_Mass_in_R200) + "\n"
        tmp += "    c_nfw             = " + str(self.halo0_c_nfw) + "\n"
        tmp += "    R200              = " + str(self.halo0_R200) + "\n"
        tmp += "    a_hernquist       = " + str(self.halo0_a_hernquist) + "\n"
        tmp += "    rho0_gas          = " + str(self.halo0_rho0gas_cgs) + "\n"
        tmp += "    rho0_gas          = " + str(self.halo0_rho0gas_gadget) + "\n"
        tmp += "    beta              = " + str(self.halo0_beta) + "\n"
        tmp += "    rc                = " + str(self.halo0_rc) + "\n"
        # tmp += "    rcut              = " + str(self.halo0_rcut) + "\n"
        tmp += "    R500              = " + str(self.halo0_R500) + "\n"
        tmp += "    bf_200            = " + str(self.halo0_bf_200) + "\n"
        tmp += "    bf_500            = " + str(self.halo0_bf_500) + "\n\n"

        # System Setup
        tmp += self.lines[self.setup_i].strip() + "\n"
        tmp += "    Boxsize           = " + str(self.system_boxsize) + "\n"
        tmp += "    Total Mass        = " + str(self.system_TotalMass) + "\n"
        tmp += "    Mass in Gas       = " + str(self.system_Mass_in_gas) + "\n"
        tmp += "    Mass in DM        = " + str(self.system_Mass_in_DM) + "\n"
        tmp += "    Mass Ratio        = " + str(self.system_Mass_Ratio) + "\n"
        tmp += "    given bf          = " + str(self.system_given_bf) + "\n"
        tmp += "    boxwide bf        = " + str(self.system_boxwide_bf) + "\n"
        tmp += "    # of Particles    = " + str(self.system_npart) + "\n"
        tmp += "    Sph Part Mass     = " + str(self.system_Sph_Part_mass) + "\n"
        tmp += "    DM Part Mass      = " + str(self.system_DM_Part_mass) + "\n"
        tmp += "    Npart Parent      = " + str(self.system_npart_partent) + "\n"
        tmp += "    Npart Bullet      = " + str(self.system_npart_bullet) + "\n"
        tmp += "    Npart Total       = " + str(self.system_npart_total) + "\n\n"

        tmp += "Grav. Softening ~ {0}".format(self.grav_softening)
        tmp += "\n\n"

        return tmp


if __name__ == '__main__':
    log = Toycluster2RuntimeOutputParser(filename="../input/runToycluster.sh.o9776543")
    data = Gadget2BinaryF77UnformattedType2Parser(filename="../input/IC_single_0")
    print log
    print data
